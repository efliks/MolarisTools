#-------------------------------------------------------------------------------
# . File      : QMCallerGaussian.py
# . Program   : MolarisTools
# . Copyright : USC, Mikolaj Feliks (2015-2017)
# . License   : GNU GPL v3.0       (http://www.gnu.org/licenses/gpl-3.0.en.html)
#-------------------------------------------------------------------------------
import subprocess, os.path, exceptions, collections

from MolarisTools.Utilities  import WriteData
from MolarisTools.Parser     import GaussianOutputFile
from MolarisTools.QMMM       import QMCaller, CS_MULLIKEN, CS_CHELPG, CS_MERZKOLLMAN


Force       = collections.namedtuple ("Force"    , "x  y  z")

class QMCallerGaussian (QMCaller):
    """A class to provide communication between Molaris and Gaussian."""

    # . Options specific to Gaussian
    # . Memory is given in GB
    # . env may define variables such as GAUSS_EXEDIR and GAUSS_SCRDIR
    # . restart means to reuse the wavefunction from the checkpoint file
    defaultAttributes = {
        "env"                     :   None            ,
        "ncpu"                    :   1               ,
        "memory"                  :   1               ,
        "method"                  :   "B3LYP/6-31G*"  ,
        "restart"                 :   False           ,
        "extraOptions"            :   None            ,
        "fileGaussianError"       :   "job.err"       ,
        "fileGaussianInput"       :   "job.inp"       ,
        "fileGaussianOutput"      :   "job.log"       ,
        "fileGaussianCheckpoint"  :   "job.chk"       ,
        "SCFConvergence"          :   10              ,
        "pathGaussian"            :   os.path.join (os.environ["HOME"], "local", "opt", "g03", "g03") ,
            }
    defaultAttributes.update (QMCaller.defaultAttributes)


    def __init__ (self, **keywordArguments):
        """Constructor."""
        super (QMCallerGaussian, self).__init__ (**keywordArguments)
        # . Determine if a semiempirical potential is used
        method = self.method[:3]
        if method in ("AM1", "PM3", ) and self.qmmm:
            raise exceptions.StandardError ("Point charges cannot be used with semiempirical methods.")
        # . Reuse the wavefunction if the checkpoint file exists
        if self.fileGaussianCheckpoint:
            self.restart = os.path.exists (self.fileGaussianCheckpoint) and self.restart
        else:
            self.restart = False
        # . Prepare a Gaussian input file
        self._WriteInput ()


    def _WriteInput (self):
        """Write a Gaussian input file."""
        # . Write job control
        data = []
        if self.ncpu > 1:
            data.append ("%%NProcShared=%d\n" % self.ncpu)
        if self.memory:
            data.append ("%%mem=%dgb\n" % self.memory)
        if self.fileGaussianCheckpoint:
            data.append ("%%chk=%s\n" % self.fileGaussianCheckpoint)

        # . Set up a charge scheme
        schemes = {
            CS_MULLIKEN     :   ""           ,
            CS_CHELPG       :   "POP=CHELPG" ,
            CS_MERZKOLLMAN  :   "POP=MK"     ,
            }
        if not schemes.has_key (self.chargeScheme):
            raise exceptions.StandardError ("Charge scheme %s is undefined." % self.chargeScheme)
        chargeScheme = schemes[self.chargeScheme]

        # . Include extra options, if any present
        if self.extraOptions:
            if isinstance (self.extraOptions, tuple):
                extraOptions = " ".join (self.extraOptions)
            else:
                extraOptions = self.extraOptions
        else:
            extraOptions = ""
        # . Write header
        if   self.qmmm:
            background = "Charge Prop=(Field,Read)"
        elif self.cosmo:
            background = "SCRF=(Solvent=Water,Read)"
        else:
            background = ""
        if   self.restart:
            restart = "Guess=Read"
        else:
            restart = ""
        if self.SCFConvergence != 6:
            scfConvergence = "SCF=(Conver=%d)" % self.SCFConvergence
        else:
            scfConvergence = ""
        keywords = (
            self.method     ,
            "NoSymm"        ,
            "Force"         ,
            background      ,
            restart         ,
            chargeScheme    ,
            scfConvergence  ,
            extraOptions    ,
            )
        header   = " ".join (keywords)
        data.append ("#P " + header + "\n\n")
        mdstep   = ""
        if hasattr (self.molaris, "mdstep"):
            mdstep = " (MD step: %d)" % self.molaris.mdstep
        data.append ("Input file generated by MolarisTools%s.\n\n" % mdstep)
        data.append ("%d %d\n" % (self.charge, self.multiplicity))
        # . Write geometry
        atoms = self.molaris.qatoms + self.molaris.latoms
        for atom in atoms:
            data.append ("%2s    %16.10f    %16.10f    %16.10f\n" % (atom.label, atom.x, atom.y, atom.z))
        data.append ("\n")
        # . If cosmo=True, write epsilon
        if self.cosmo:
            data.append ("eps=%f\n\n" % self.dielectric)
        # . Write point charges
        if self.qmmm:
            pointCharges = self.molaris.patoms + self.molaris.watoms
            for atom in pointCharges:
                data.append ("%16.10f    %16.10f    %16.10f    %16.10f\n" % (atom.x, atom.y, atom.z, atom.charge))
            data.append ("\n")
            # . Write points where the electric field is be calculated
            for atom in pointCharges:
                data.append ("%16.10f    %16.10f    %16.10f\n" % (atom.x, atom.y, atom.z))
            data.append ("\n")
        # . Finish up
        WriteData (data, self.fileGaussianInput)


    def Run (self):
        """Run the calculation."""
        fileError  = open (self.fileGaussianError, "w")
        if self.env:
            subprocess.check_call ([self.pathGaussian, self.fileGaussianInput], stdout=fileError, stderr=fileError, env=self.env)
        else:
            subprocess.check_call ([self.pathGaussian, self.fileGaussianInput], stdout=fileError, stderr=fileError)
        fileError.close ()
        # . Parse the output file
        gaussian     = GaussianOutputFile (filename=self.fileGaussianOutput)
        # . Important: if there are point charges, remove their self interaction energy from the final QM energy
        self.Efinal  = (gaussian.Efinal - gaussian.Echrg) if self.qmmm else gaussian.Efinal
        # . Include forces on QM atoms
        self.forces  = gaussian.forces
        # . Include forces on point charges
        if hasattr (gaussian, "pointCharges"):
            mmforces = []
            for pc in gaussian.pointCharges:
                force = Force (
                    x   =   pc.ex   *   pc.charge   ,
                    y   =   pc.ey   *   pc.charge   ,
                    z   =   pc.ez   *   pc.charge   , )
                mmforces.append (force)
            self.mmforces = mmforces
        # . Include charges
        scheme = {
            CS_MULLIKEN     :   gaussian.charges    if hasattr (gaussian, "charges"   ) else []  ,
            CS_CHELPG       :   gaussian.espcharges if hasattr (gaussian, "espcharges") else []  ,
            CS_MERZKOLLMAN  :   gaussian.espcharges if hasattr (gaussian, "espcharges") else []  , }
        self.charges = scheme[self.chargeScheme]
        # . Include timing information
        self.jobtime = gaussian.jobtime
        # . Finish up
        self._Finalize ()


#===============================================================================
# . Main program
#===============================================================================
if __name__ == "__main__": pass
